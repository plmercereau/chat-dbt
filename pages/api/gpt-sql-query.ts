import { getIntrospection } from '@/util/introspection'
import { getSqlConnection } from '@/util/sql-connection'
import type { NextApiRequest, NextApiResponse } from 'next'
import { PostgresError } from 'postgres'
import { Configuration, OpenAIApi } from 'openai'

const configuration = new Configuration({
    apiKey: process.env.OPENAI_API_KEY,
    organization: process.env.OPENAI_ORGANISATION
})
const openai = new OpenAIApi(configuration)

export type GptSqlResult = {
    query?: string
    result?: any
    error?: string
}

const parseValue = (value: any) => {
    if (typeof value !== 'string') {
        return value
    }
    try {
        return JSON.parse(value)
    } catch {
        return value
    }
}

export default async function handler(
    req: NextApiRequest,
    res: NextApiResponse<GptSqlResult>
) {
    // * Get the SQL introspection
    const schema = JSON.stringify(await getIntrospection(), null, 0)
    // * Get the request
    // * Example: Number of users who have a first name starting with 'A'
    const { query } = req.body
    if (!query) {
        return res.status(400).json({ error: 'no request' })
    }
    // * Create the prompt
    try {
        // * Query OpenAI
        const completion = await openai.createChatCompletion({
            model: 'gpt-4',
            messages: [
                {
                    role: 'system',
                    content:
                        'You are a postgresql developer that only responds in sql without formatting'
                },
                {
                    role: 'system',
                    content: 'uuids should be generated with gen_random_uuid()'
                },
                // {
                //     role: 'system',
                //     content:
                //         'All SQL tables should have a primary key, preferrably an column named id of type uuid (autogenerated)'
                // },
                {
                    role: 'system',
                    content: 'queries on strings should be case insensitive'
                },
                {
                    role: 'system',
                    content:
                        'singleton queries should wrap their result in a json_build_object, that should be aliased _data'
                },
                {
                    role: 'system',
                    content: `database: ${schema}`
                },
                {
                    role: 'user',
                    content: query
                }
            ],
            temperature: 0
        })
        const sqlQuery = completion.data.choices[0].message?.content
        if (!sqlQuery) {
            return res.status(400).json({ error: 'empty response' })
        }
        try {
            const sql = getSqlConnection()
            // * 5. Run the SQL query
            const sqlResult = await sql.unsafe<{ _data?: any }[]>(sqlQuery)

            if (
                sqlResult.columns?.length === 1 &&
                sqlResult.columns.find(col => col.name === '_data')
            ) {
                if (sqlResult.length === 0) {
                    return res
                        .status(200)
                        .json({ query: sqlQuery, result: null })
                }
                if (sqlResult.length === 1) {
                    return res.status(200).json({
                        query: sqlQuery,
                        result: parseValue(sqlResult[0]._data)
                    })
                }
                return res.status(200).json({
                    query: sqlQuery,

                    result: sqlResult.map(value => value['_data'])
                })
            }
            return res.status(200).json({ query: sqlQuery, result: sqlResult })
        } catch (e) {
            const error = e as PostgresError
            return res
                .status(500)
                .send({ query: sqlQuery, error: error.message })
        }
    } catch (e) {
        const error = e as Error
        return res.status(500).send({ error: error.message })
    }
}
